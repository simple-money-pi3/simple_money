-- ============================================================================
-- SIMPLEMONEY - SCHEMA COMPLETO PARA SUPABASE
-- ============================================================================
-- Este arquivo contém todas as queries SQL necessárias para criar o banco
-- de dados do SimpleMoney no Supabase.
--
-- INSTRUÇÕES:
-- 1. Acesse o SQL Editor no dashboard do Supabase
-- 2. Execute as queries na ordem apresentada
-- 3. Após criar as tabelas, configure as políticas RLS no dashboard
-- ============================================================================

-- ============================================================================
-- EXTENSÕES
-- ============================================================================
-- Habilita extensões úteis do PostgreSQL
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================================
-- TABELA: users
-- ============================================================================
-- Armazena informações dos usuários
-- NOTA: O Supabase já possui auth.users para autenticação.
-- Esta tabela armazena dados adicionais do perfil do usuário.
-- ============================================================================

CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    auth_user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
    email VARCHAR(255) UNIQUE NOT NULL,
    password VARCHAR(255), -- Hash da senha (opcional se usar auth.users)
    name VARCHAR(255),
    phone VARCHAR(20),
    photo TEXT, -- URL ou base64 da foto
    age INTEGER,
    user_type VARCHAR(50) CHECK (user_type IN ('adult', 'teen', 'child')),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE -- Soft delete
);

-- Índices para a tabela users
CREATE INDEX IF NOT EXISTS idx_users_auth_user_id ON users(auth_user_id);
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
CREATE INDEX IF NOT EXISTS idx_users_deleted_at ON users(deleted_at) WHERE deleted_at IS NULL;

-- Trigger para atualizar updated_at automaticamente
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_users_updated_at
    BEFORE UPDATE ON users
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- TABELA: user_profiles
-- ============================================================================
-- Armazena informações adicionais do perfil do usuário
-- Relacionamento 1:1 com users
-- ============================================================================

CREATE TABLE IF NOT EXISTS user_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL UNIQUE REFERENCES users(id) ON DELETE CASCADE,
    points INTEGER DEFAULT 0 CHECK (points >= 0),
    balance DECIMAL(10, 2) DEFAULT 0,
    preferences JSONB DEFAULT '{}'::jsonb, -- Para armazenar preferências em formato JSON
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para a tabela user_profiles
CREATE UNIQUE INDEX IF NOT EXISTS idx_user_profiles_user_id ON user_profiles(user_id);

-- Trigger para atualizar updated_at automaticamente
CREATE TRIGGER update_user_profiles_updated_at
    BEFORE UPDATE ON user_profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- TABELA: transactions
-- ============================================================================
-- Armazena transações financeiras (entradas e saídas)
-- ============================================================================

CREATE TABLE IF NOT EXISTS transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    name VARCHAR(255) NOT NULL,
    value DECIMAL(10, 2) NOT NULL CHECK (value > 0),
    type VARCHAR(20) NOT NULL CHECK (type IN ('income', 'expense')),
    category VARCHAR(100) NOT NULL,
    date DATE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE -- Soft delete
);

-- Índices para a tabela transactions
CREATE INDEX IF NOT EXISTS idx_transactions_user_id ON transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_transactions_date ON transactions(date);
CREATE INDEX IF NOT EXISTS idx_transactions_type ON transactions(type);
CREATE INDEX IF NOT EXISTS idx_transactions_category ON transactions(category);
CREATE INDEX IF NOT EXISTS idx_transactions_user_date ON transactions(user_id, date);
CREATE INDEX IF NOT EXISTS idx_transactions_deleted_at ON transactions(deleted_at) WHERE deleted_at IS NULL;

-- Trigger para atualizar updated_at automaticamente
CREATE TRIGGER update_transactions_updated_at
    BEFORE UPDATE ON transactions
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- TABELA: goals
-- ============================================================================
-- Armazena metas financeiras dos usuários
-- ============================================================================

CREATE TABLE IF NOT EXISTS goals (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    target_value DECIMAL(10, 2) NOT NULL CHECK (target_value > 0),
    current_value DECIMAL(10, 2) DEFAULT 0 CHECK (current_value >= 0),
    category VARCHAR(100),
    target_date DATE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    deleted_at TIMESTAMP WITH TIME ZONE -- Soft delete
);

-- Índices para a tabela goals
CREATE INDEX IF NOT EXISTS idx_goals_user_id ON goals(user_id);
CREATE INDEX IF NOT EXISTS idx_goals_user_target_date ON goals(user_id, target_date);
CREATE INDEX IF NOT EXISTS idx_goals_deleted_at ON goals(deleted_at) WHERE deleted_at IS NULL;

-- Trigger para atualizar updated_at automaticamente
CREATE TRIGGER update_goals_updated_at
    BEFORE UPDATE ON goals
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- ============================================================================
-- TABELA: challenges
-- ============================================================================
-- Armazena desafios aceitos pelos usuários
-- ============================================================================

CREATE TABLE IF NOT EXISTS challenges (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    challenge_id VARCHAR(50) NOT NULL, -- ID do desafio (ex: '1', '2', etc.)
    title VARCHAR(255) NOT NULL,
    description TEXT,
    target DECIMAL(10, 2) NOT NULL CHECK (target > 0),
    current DECIMAL(10, 2) DEFAULT 0 CHECK (current >= 0),
    reward INTEGER DEFAULT 0, -- Pontos de recompensa
    status VARCHAR(20) DEFAULT 'active' CHECK (status IN ('active', 'completed', 'abandoned')),
    accepted_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    completed_at TIMESTAMP WITH TIME ZONE,
    abandoned_at TIMESTAMP WITH TIME ZONE
);

-- Índices para a tabela challenges
CREATE INDEX IF NOT EXISTS idx_challenges_user_id ON challenges(user_id);
CREATE INDEX IF NOT EXISTS idx_challenges_status ON challenges(status);
CREATE UNIQUE INDEX IF NOT EXISTS idx_challenges_user_challenge ON challenges(user_id, challenge_id);

-- ============================================================================
-- TABELA: achievements
-- ============================================================================
-- Armazena conquistas do usuário
-- ============================================================================

CREATE TABLE IF NOT EXISTS achievements (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    icon VARCHAR(50),
    date DATE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para a tabela achievements
CREATE INDEX IF NOT EXISTS idx_achievements_user_id ON achievements(user_id);
CREATE INDEX IF NOT EXISTS idx_achievements_user_date ON achievements(user_id, date);

-- ============================================================================
-- TABELA: notifications
-- ============================================================================
-- Armazena notificações de eventos (metas batidas, desafios, transações, etc.)
-- Cada notificação está associada a um usuário
-- ============================================================================

CREATE TABLE IF NOT EXISTS notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    type VARCHAR(50) NOT NULL, -- Exemplo: 'goal', 'challenge', 'transaction', etc
    read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    read_at TIMESTAMP WITH TIME ZONE
);

-- Índices para consultas rápidas
CREATE INDEX IF NOT EXISTS idx_notifications_user_id ON notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_read ON notifications(read);
CREATE INDEX IF NOT EXISTS idx_notifications_user_read ON notifications(user_id, read);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS)
-- ============================================================================
-- Habilita RLS em todas as tabelas
-- ============================================================================

ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE goals ENABLE ROW LEVEL SECURITY;
ALTER TABLE challenges ENABLE ROW LEVEL SECURITY;
ALTER TABLE achievements ENABLE ROW LEVEL SECURITY;
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- POLÍTICAS RLS: users
-- ============================================================================

-- Política: Usuários podem visualizar seu próprio perfil
CREATE POLICY "Users can view own profile"
    ON users FOR SELECT
    USING (auth.uid() = auth_user_id);

-- Política: Usuários podem atualizar seu próprio perfil
CREATE POLICY "Users can update own profile"
    ON users FOR UPDATE
    USING (auth.uid() = auth_user_id);

-- Política: Usuários podem inserir seu próprio perfil
-- Permite inserção durante registro (quando auth.uid() corresponde ao auth_user_id)
CREATE POLICY "Users can insert own profile"
    ON users FOR INSERT
    WITH CHECK (
        auth.uid() = auth_user_id AND
        auth.uid() IS NOT NULL
    );

-- ============================================================================
-- POLÍTICAS RLS: user_profiles
-- ============================================================================

-- Política: Usuários podem visualizar seu próprio perfil
CREATE POLICY "Users can view own user_profile"
    ON user_profiles FOR SELECT
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem atualizar seu próprio perfil
CREATE POLICY "Users can update own user_profile"
    ON user_profiles FOR UPDATE
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem inserir seu próprio perfil
CREATE POLICY "Users can insert own user_profile"
    ON user_profiles FOR INSERT
    WITH CHECK (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- ============================================================================
-- POLÍTICAS RLS: transactions
-- ============================================================================

-- Política: Usuários podem visualizar suas próprias transações
CREATE POLICY "Users can view own transactions"
    ON transactions FOR SELECT
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem inserir suas próprias transações
CREATE POLICY "Users can insert own transactions"
    ON transactions FOR INSERT
    WITH CHECK (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem atualizar suas próprias transações
CREATE POLICY "Users can update own transactions"
    ON transactions FOR UPDATE
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem deletar suas próprias transações
CREATE POLICY "Users can delete own transactions"
    ON transactions FOR DELETE
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- ============================================================================
-- POLÍTICAS RLS: goals
-- ============================================================================

-- Política: Usuários podem visualizar suas próprias metas
CREATE POLICY "Users can view own goals"
    ON goals FOR SELECT
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem inserir suas próprias metas
CREATE POLICY "Users can insert own goals"
    ON goals FOR INSERT
    WITH CHECK (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem atualizar suas próprias metas
CREATE POLICY "Users can update own goals"
    ON goals FOR UPDATE
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem deletar suas próprias metas
CREATE POLICY "Users can delete own goals"
    ON goals FOR DELETE
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- ============================================================================
-- POLÍTICAS RLS: challenges
-- ============================================================================

-- Política: Usuários podem visualizar seus próprios desafios
CREATE POLICY "Users can view own challenges"
    ON challenges FOR SELECT
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem inserir seus próprios desafios
CREATE POLICY "Users can insert own challenges"
    ON challenges FOR INSERT
    WITH CHECK (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem atualizar seus próprios desafios
CREATE POLICY "Users can update own challenges"
    ON challenges FOR UPDATE
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem deletar seus próprios desafios
CREATE POLICY "Users can delete own challenges"
    ON challenges FOR DELETE
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- ============================================================================
-- POLÍTICAS RLS: achievements
-- ============================================================================

-- Política: Usuários podem visualizar suas próprias conquistas
CREATE POLICY "Users can view own achievements"
    ON achievements FOR SELECT
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: Usuários podem inserir suas próprias conquistas
CREATE POLICY "Users can insert own achievements"
    ON achievements FOR INSERT
    WITH CHECK (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- ============================================================================
-- POLÍTICAS RLS: notifications
-- ============================================================================
-- Habilita Row Level Security (RLS) para segurança de dados

-- Política: usuários só podem visualizar suas próprias notificações
CREATE POLICY "Users can view own notifications"
    ON notifications FOR SELECT
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: usuários só podem inserir suas próprias notificações
CREATE POLICY "Users can insert own notifications"
    ON notifications FOR INSERT
    WITH CHECK (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: usuários só podem atualizar suas próprias notificações
CREATE POLICY "Users can update own notifications"
    ON notifications FOR UPDATE
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- Política: usuários só podem deletar suas próprias notificações
CREATE POLICY "Users can delete own notifications"
    ON notifications FOR DELETE
    USING (auth.uid() = (SELECT auth_user_id FROM users WHERE id = user_id));

-- ============================================================================
-- FUNÇÕES AUXILIARES
-- ============================================================================

-- Função para calcular o saldo total do usuário baseado nas transações
CREATE OR REPLACE FUNCTION calculate_user_balance(p_user_id UUID)
RETURNS DECIMAL(10, 2) AS $$
DECLARE
    total_balance DECIMAL(10, 2);
BEGIN
    SELECT COALESCE(
        SUM(CASE WHEN type = 'income' THEN value ELSE -value END),
        0
    ) INTO total_balance
    FROM transactions
    WHERE user_id = p_user_id
    AND deleted_at IS NULL;
    
    RETURN total_balance;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Função para atualizar o saldo do perfil do usuário
CREATE OR REPLACE FUNCTION update_user_profile_balance()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE user_profiles
    SET balance = calculate_user_balance(NEW.user_id),
        updated_at = NOW()
    WHERE user_id = NEW.user_id;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger para atualizar o saldo automaticamente quando uma transação é criada/atualizada/deletada
CREATE TRIGGER update_balance_on_transaction_insert
    AFTER INSERT ON transactions
    FOR EACH ROW
    EXECUTE FUNCTION update_user_profile_balance();

CREATE TRIGGER update_balance_on_transaction_update
    AFTER UPDATE ON transactions
    FOR EACH ROW
    EXECUTE FUNCTION update_user_profile_balance();

CREATE TRIGGER update_balance_on_transaction_delete
    AFTER DELETE ON transactions
    FOR EACH ROW
    EXECUTE FUNCTION update_user_profile_balance();

-- ============================================================================
-- COMENTÁRIOS NAS TABELAS E COLUNAS
-- ============================================================================

COMMENT ON TABLE users IS 'Armazena informações dos usuários do sistema';
COMMENT ON COLUMN users.auth_user_id IS 'Referência ao usuário de autenticação do Supabase (auth.users)';
COMMENT ON COLUMN users.deleted_at IS 'Data de exclusão (soft delete)';

COMMENT ON TABLE user_profiles IS 'Armazena informações adicionais do perfil do usuário (pontos, saldo, preferências)';
COMMENT ON COLUMN user_profiles.preferences IS 'Preferências do usuário em formato JSON (ex: tema, sons, etc.)';

COMMENT ON TABLE transactions IS 'Armazena transações financeiras (entradas e saídas)';
COMMENT ON COLUMN transactions.type IS 'Tipo da transação: income (entrada) ou expense (saída)';
COMMENT ON COLUMN transactions.deleted_at IS 'Data de exclusão (soft delete)';

COMMENT ON TABLE goals IS 'Armazena metas financeiras dos usuários';
COMMENT ON COLUMN goals.target_value IS 'Valor alvo da meta';
COMMENT ON COLUMN goals.current_value IS 'Valor atual acumulado na meta';

COMMENT ON TABLE challenges IS 'Armazena desafios aceitos pelos usuários';
COMMENT ON COLUMN challenges.status IS 'Status do desafio: active, completed ou abandoned';

COMMENT ON TABLE achievements IS 'Armazena conquistas desbloqueadas pelos usuários';
COMMENT ON TABLE notifications IS 'Armazena notificações dos usuários (eventos, conquistas, inclusões, etc)';
COMMENT ON COLUMN notifications.read IS 'FALSE se não lida, TRUE se lida pelo usuário';
COMMENT ON COLUMN notifications.type IS 'goal, challenge, transaction, etc';

-- ============================================================================
-- FIM DO SCHEMA
-- ============================================================================
-- 
-- PRÓXIMOS PASSOS:
-- 1. Execute este script no SQL Editor do Supabase
-- 2. Verifique se todas as tabelas foram criadas corretamente
-- 3. Teste as políticas RLS criando um usuário de teste
-- 4. Configure as variáveis de ambiente no seu projeto Next.js
-- 
-- VARIÁVEIS DE AMBIENTE NECESSÁRIAS:
-- NEXT_PUBLIC_SUPABASE_URL=https://seu-projeto.supabase.co
-- NEXT_PUBLIC_SUPABASE_ANON_KEY=sua-chave-anon-key
-- SUPABASE_SERVICE_ROLE_KEY=sua-chave-service-role (apenas server-side)
-- ============================================================================

